{% extends "admin/change_form.html" %}
{% load i18n admin_urls %}

{% block extrahead %}
{{ block.super }}
<script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
<style>
.react-flow {
  height: 100%;
  width: 100%;
}
.react-flow__node {
  padding: 10px;
  border-radius: 3px;
  width: 150px;
  font-size: 12px;
  color: #222;
  text-align: center;
  border-width: 1px;
  border-style: solid;
  background: #fff;
  border-color: #1a192b;
  cursor: pointer;
}
.react-flow__node-input {
  background: #f6f6f6;
}
.react-flow__edge-path {
  stroke: #333;
  stroke-width: 2;
}
.react-flow__handle {
  width: 8px;
  height: 8px;
  background: #1a192b;
}
#event-details {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 80%;
  height: 80%;
  background: white;
  border: 1px solid #ddd;
  padding: 15px;
  box-shadow: 0 0 10px rgba(0,0,0,0.1);
  z-index: 1000;
  overflow-y: auto;
}
</style>
{% endblock %}

{% block content %}
<h1>{{ original.name }}</h1>
<p>Start Time: {{ original.start_time }}</p>
<p>End Time: {{ original.end_time }}</p>


<button id="rerunFirstEvent" style="margin-bottom: 20px;">Rerun First Event</button>

<div id="react-flow-root" style="height: 8000px; width: 3000px; overflow: auto;"></div>
<div id="event-details" style="display: none;"></div>

<script>
  function forestLayout(nodes, edges) {
    const nodeWidth = 150;
    const nodeHeight = 40;
    const verticalSpacing = 100;
    const horizontalSpacing = 200;
    const forestSpacing = 500;
    
    const nodeMap = new Map(nodes.map(node => [node.id, { ...node, children: [], positioned: false }]));
    
    edges.forEach(edge => {
      const parent = nodeMap.get(edge.source);
      const child = nodeMap.get(edge.target);
      if (parent && child) {
        parent.children.push(child);
      }
    });
    
    const roots = Array.from(nodeMap.values()).filter(node => 
      !edges.some(edge => edge.target === node.id)
    );
    
    function setPositions(node, x, y, level) {
      if (node.positioned) return;
      
      node.position = { x, y };
      node.positioned = true;
      const childrenCount = node.children.length;
      const totalWidth = (childrenCount - 1) * horizontalSpacing;
      const startX = x - totalWidth / 2;
      
      node.children.forEach((child, index) => {
        const childX = startX + index * horizontalSpacing;
        setPositions(child, childX, y + verticalSpacing, level + 1);
      });
    }
    
    let forestX = 0;
    roots.forEach(root => {
      setPositions(root, forestX, 0, 0);
      forestX += forestSpacing;
    });
    
    let remainingY = 0;
    nodeMap.forEach(node => {
      if (!node.positioned) {
        node.position = { x: forestX, y: remainingY };
        remainingY += verticalSpacing;
      }
    });
    
    return Array.from(nodeMap.values());
  }

  const ReactFlow = {
    default: function ReactFlow({ nodes, edges, onNodeClick, onDeleteNode }) {
      const nodeWidth = 150;
      const nodeHeight = 40;
  
      const nodeElements = nodes.map(node => 
        React.createElement('div', {
          key: node.id,
          style: {
            position: 'absolute',
            left: node.position.x + 'px',
            top: node.position.y + 'px',
            width: nodeWidth + 'px',
            height: nodeHeight + 'px',
            padding: '10px',
            border: '1px solid #ddd',
            borderRadius: '5px',
            background: node.type === 'input' ? '#f6f6f6' : '#fff',
            cursor: 'pointer'
          }
        }, 
          React.createElement('div', {
            onClick: () => onNodeClick(node)
          }, node.data.label),
          node.id !== 'recording' && React.createElement('button', {
            onClick: (e) => {
              e.stopPropagation();
              onDeleteNode(node.id);
            },
            style: {
              position: 'absolute',
              top: '2px',
              right: '2px',
              background: 'red',
              color: 'white',
              border: 'none',
              borderRadius: '50%',
              width: '20px',
              height: '20px',
              fontSize: '12px',
              cursor: 'pointer'
            }
          }, 'X')
        )
      );
  
      const edgeElements = edges.map(edge => {
        const sourceNode = nodes.find(n => n.id === edge.source);
        const targetNode = nodes.find(n => n.id === edge.target);
  
        if (!sourceNode || !targetNode) {
          console.error('Missing node for edge:', edge);
          return null;
        }
  
        const sourceX = sourceNode.position.x + nodeWidth / 2;
        const sourceY = sourceNode.position.y + nodeHeight;
        const targetX = targetNode.position.x + nodeWidth / 2;
        const targetY = targetNode.position.y;
  
        return React.createElement('svg', {
          key: edge.id,
          style: {
            position: 'absolute',
            left: 0,
            top: 0,
            width: '100%',
            height: '100%',
            pointerEvents: 'none'
          }
        }, React.createElement('path', {
          d: `M ${sourceX},${sourceY} L ${sourceX},${(sourceY + targetY) / 2} L ${targetX},${(sourceY + targetY) / 2} L ${targetX},${targetY}`,
          fill: 'none',
          stroke: 'black',
          strokeWidth: 2
        }));
      }).filter(Boolean);
  
      return React.createElement('div', {
        style: { position: 'relative', width: '100%', height: '100%' }
      }, ...nodeElements, ...edgeElements);
    }
  };
  
  const graphData = JSON.parse('{{ graph_data|escapejs }}');
  const adminEvents = JSON.parse('{{ action_runs|escapejs }}');
  console.log('Graph data:', graphData);
  console.log('Total nodes:', graphData.nodes.length);
  console.log('Total edges:', graphData.edges.length);
  console.log('Admin events:', adminEvents);
  
  function Flow() {
    const [nodes, setNodes] = React.useState(() => forestLayout(graphData.nodes, graphData.edges));
    const [edges, setEdges] = React.useState(graphData.edges);
    const [selectedEvent, setSelectedEvent] = React.useState(null);
  
    const handleNodeClick = async (node) => {
      console.log('Node clicked:', node);
      let eventId;
      if (node.id === 'recording') {
        eventId = adminEvents[0].id.toString();
      } else {
        const index = parseInt(node.id.replace('event_', ''), 10);
        eventId = adminEvents[index] ? adminEvents[index].id.toString() : null;
      }
      console.log('Looking for event with id:', eventId);
      const event = adminEvents.find(e => e.id.toString() === eventId);
      console.log('Found event:', event);
      setSelectedEvent(event);
      const detailsElement = document.getElementById('event-details');
      if (event) {
        try {
          const response = await fetch(`/workspaces/1/admin/action_runs/actionrun/${event.id}/change/`);
          if (response.ok) {
            const html = await response.text();
            detailsElement.innerHTML = html;
            detailsElement.style.display = 'block';
            
            // Remove the header, submit row, and other unnecessary elements
            const elementsToRemove = detailsElement.querySelectorAll('.navbar, .submit-row, .breadcrumbs');
            elementsToRemove.forEach(el => el.remove());
            
            // Disable all inputs
            const inputs = detailsElement.querySelectorAll('input, select, textarea');
            inputs.forEach(input => input.disabled = true);
          } else {
            throw new Error('Failed to fetch admin change form');
          }
        } catch (error) {
          console.error('Error fetching admin change form:', error);
          detailsElement.innerHTML = `
            <h3>${event.action} on ${event.model_name}</h3>
            <p>Timestamp: ${event.timestamp}</p>
            <p>User: ${event.user}</p>
            <pre>${JSON.stringify(event.data, null, 2)}</pre>
          `;
          detailsElement.style.display = 'block';
        }
      } else {
        console.log('No event found, showing debug info');
        detailsElement.innerHTML = `
          <h3>Debug Info</h3>
          <p>Node ID: ${node.id}</p>
          <p>Event ID: ${eventId}</p>
          <p>Admin Events: ${JSON.stringify(adminEvents, null, 2)}</p>
        `;
        detailsElement.style.display = 'block';
      }
    };
    const handleDeleteNode = async (nodeId) => {
      console.log('Deleting node:', nodeId);
      let eventId;
      if (nodeId === 'recording') {
        console.error('Cannot delete recording node');
        return;
      } else {
        const index = parseInt(nodeId.replace('event_', ''), 10);
        eventId = adminEvents[index] ? adminEvents[index].id.toString() : null;
      }
      
      if (eventId) {
        try {
          const formData = new FormData();
          formData.append('action', 'detach_from_recording');
          formData.append('_selected_action', eventId);
          formData.append('post', 'yes');
    
          const response = await fetch(`/workspaces/1/admin/action_runs/actionrun/`, {
            method: 'POST',
            headers: {
              'X-CSRFToken': getCookie('csrftoken'),
              'X-Requested-With': 'XMLHttpRequest'
            },
            body: formData
          });
    
          if (response.ok) {
            setNodes(prevNodes => prevNodes.filter(node => node.id !== nodeId));
            setEdges(prevEdges => prevEdges.filter(edge => edge.source !== nodeId && edge.target !== nodeId));
            console.log('Node deleted successfully');
          } else {
            throw new Error('Failed to delete node');
          }
        } catch (error) {
          console.error('Error deleting node:', error);
          alert(`Failed to delete node: ${error.message}`);
        }
      } else {
        console.error('No corresponding event found for node:', nodeId);
      }
    };

    return React.createElement(ReactFlow.default, {
      nodes: nodes,
      edges: edges,
      onNodeClick: handleNodeClick,
      onDeleteNode: handleDeleteNode
    });
  }
  
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }

  ReactDOM.render(
    React.createElement(Flow),
    document.getElementById('react-flow-root')
  );
</script>

<script>
  document.getElementById('rerunFirstEvent').addEventListener('click', async function() {
    if (adminEvents.length > 0) {
      const firstEvent = adminEvents[0];
      try {
        const response = await fetch('/workspaces/1/admin/action_runs/actionrun/rerun/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken'),
          },
          body: JSON.stringify({ event_id: firstEvent.id }),
        });
  
        if (response.ok) {
          const result = await response.json();
          alert('Event rerun successfully: ' + result.message);
          // Optionally, refresh the page or update the graph
          location.reload();
        } else {
          throw new Error('Failed to rerun event');
        }
      } catch (error) {
        console.error('Error rerunning event:', error);
        alert('Failed to rerun event: ' + error.message);
      }
    } else {
      alert('No events to rerun');
    }
  });
  </script>

{% endblock %}