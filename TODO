make sure there is no nullable charfield
defensive programming on the filter by tenant: in the model manager and in every query
pgbadger
pgstats
get_absolute_url of resource
requirements folder
mozilla observatory
checkout django webtest

feature ascension: cli / django admin / api / beautiful web client
use django-ajax-datatable
should you name table.id or table.uuid, if you use uuids?
easy redirect after id change

Should you be able to delete your workspace? Probably, see clickup. The problem is that my admin page depends on a workspace. The workspace resource should be under /admin/settings or something. This way after deleting your workspace, you remain on the page.

I have very dangerous tests that should never run in production and others that are very important to run regularly in production

nice website, I should post bluewind in here too: https://app.fossa.com/projects/git%2Bgithub.com%2Ftemporalio%2Ftemporal-helm-charts/refs/branch/master/eac55bff23c021e146d9e608ab895b2ac1f11f9e/preview

add to naming conventions: adjectives should not be prefixes, they should be suffixes. session_extended over extended_session

visualize autodiscovery to give full control and transparency to the user

think more about folders: clickup and windmill have this concept. There is something useful here. For permissions, but also to give this file hierarchy...
Clickup decided to limit the number of folders as far as I understand: workspace / space / lists
I think it's a good balance. nested folders are hard.

remove id 91017349113822292053236764842401387445

URGENT: put project in root folder

I need to do something like this: https://www.reddit.com/r/aws/comments/mrpexd/finding_resources_outside_of_cloudformation_stacks/
Because I have dangling resources, things outside of my cloudformation stack

Run tests on previous commits to see if they still work, to see if changes are backwards compatible.

add vantage to AWS accounts
add in the CI a step that checks if things work ok.

Campaign Goal: build much needed django improvements.
Opportunities for challengers: get visibility from Django community

buttons at the top to save
no db logs in console but it still needs to be pushed to DB
don't allow /admin/ without workspaces and without making sure user is logged in
PR campaigns: this french immigrant is building an app that does everything, maybe find something different than french immigrant, more memorable.
add new rule: log a lot. but please use logger(django.temp)
evolution of number of queries for the same basic action.
get metric number of DB query grouped by request path sliced by interval of 5 minutes.
why flow run not in the search
when clicking out of command palette -> leave the palette
Learning: blacklist the word content_type. It should only be contenttype
Learning: Systematically logger what's sent to the save function
remove actionrun
learning: form inlines obviously can't be saved before their dependencies, which is why flow run argument couldn't be used. for inlines related things, use statuses.
build something that removes logs, maybe a key is to remove the import and then delete out of import lines
prevent LLMS from enforcing: models as strings "Flow"

change_form_template = (
"admin/change_form.html" -> "admin/flow_runs/flowrun/change_form.html" # Update this line
)
these types of errors are very common
very common error: writing template instead of templates
make sure LLMS can't logger big stuff. create an error if they do.
at end of feature, systematically replace logger = logging.getLogger("django.temp") with logger = logging.getLogger("django.not_used")
no message on save objects automatically added
hard code to make them use this logger
always use lazy loa
foreign key relationships always lazily loaded and always like that "file_watchers.FileWatcher"
all the empty files given by startapp should be removed
incident:
corrective actions: take actions and implement processes to fix incident
preventive actions: take actions and implement processes to prevent incident
monitoring actions: take actions and implement processes to detect incidents of this type
default logging between common functions: CREATE SAVE DELETE (maybe list?) and maybe after_save and flows with a buffer size if stuff too big
never see or have to fill workspace_id, same for user, same for created_at update_at
created_at update_at by default on all models

ACCOUNT FOR THIS:

look, after a file is changed,
if this file is in a models.py and this model is in the DB (look up the Model object),
I want to be able to save the content of the models.py. Oh, I think I need the app_label in the models.py

import logging

from django.conf import settings
from django.db import models

from workspaces.models import WorkspaceRelated

temp_logger = logging.getLogger("django.temp")

class FileChange(WorkspaceRelated):
"""
Model to represent a detected file change.
"""

    file_watcher = models.ForeignKey(
        "file_watchers.FileWatcher",
        on_delete=models.CASCADE,
        related_name="file_changes",
        help_text="The file watcher that detected this change.",
    )
    file_path = models.CharField(
        max_length=1024, help_text="The path of the file that was changed."
    )
    change_type = models.CharField(
        max_length=50,
        help_text="Type of change detected (e.g., modified, created, deleted).",
    )
    timestamp = models.DateTimeField(
        auto_now_add=True, help_text="Timestamp of when the change was detected."
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        help_text="The user responsible for the file change, if known.",
    )

    def __str__(self):
        return f"FileChanged(file_path={self.file_path}, change_type={self.change_type}, timestamp={self.timestamp})"

    def save(self, *args, **kwargs):
        temp_logger.debug(f"Saving FileChange: {self}")
        super().save(*args, **kwargs)
        temp_logger.debug(f"FileChange saved: {self}")

class Model(WorkspaceRelated):
"""
Example Django model named 'Model' inheriting from WorkspaceRelated.
This model now includes a 'content' field to store file content.
"""

    name = models.CharField(max_length=100)
    content = models.TextField(blank=True, null=True)  # Field to store file content

    def __str__(self):
        return self.name

    class Meta:
        unique_together = ("workspace", "name")

As you can see I discovered a task while working on one. In this case I should save the current task and not run it.

regression: when I added the watchdog feature my hot reload broke
oh actually it's fine, somehow the files in admin_autoregister are not being watched. weird.

idea: find the people who need help on the web and the people who provide a service who could help them

I forgot to commit my code before working on a new task. I need to create corrective, preventive and monitor actions for this.

edit of previous message:
I forgot to commit my code before working on a new task. I need to create preventive and monitor actions for this.

Because there is no point creating corrective actions. Corrective actions inspire preventive and monitoring ones, but they''re not really part of the improvement process ( in fact they should be avoided )

Things are getting very meta with the logs as you can see above. Talking about the logs in the logs. I have done a lot of meta things recently.
